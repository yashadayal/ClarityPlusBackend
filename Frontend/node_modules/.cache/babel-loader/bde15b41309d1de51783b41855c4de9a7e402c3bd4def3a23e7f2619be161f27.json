{"ast":null,"code":"import { areDatesEqual, replaceInvalidDateByNull } from './date-utils';\nimport { addPositionPropertiesToSections, createDateStrForInputFromSections } from '../hooks/useField/useField.utils';\nexport var singleItemValueManager = {\n  emptyValue: null,\n  getTodayValue: function getTodayValue(utils, valueType) {\n    return valueType === 'date' ? utils.startOfDay(utils.date()) : utils.date();\n  },\n  cleanValue: replaceInvalidDateByNull,\n  areValuesEqual: areDatesEqual,\n  isSameError: function isSameError(a, b) {\n    return a === b;\n  },\n  hasError: function hasError(error) {\n    return error != null;\n  },\n  defaultErrorState: null\n};\nexport var singleItemFieldValueManager = {\n  updateReferenceValue: function updateReferenceValue(utils, value, prevReferenceValue) {\n    return value == null || !utils.isValid(value) ? prevReferenceValue : value;\n  },\n  getSectionsFromValue: function getSectionsFromValue(utils, date, prevSections, isRTL, getSectionsFromDate) {\n    var shouldReUsePrevDateSections = !utils.isValid(date) && !!prevSections;\n    if (shouldReUsePrevDateSections) {\n      return prevSections;\n    }\n    return addPositionPropertiesToSections(getSectionsFromDate(date), isRTL);\n  },\n  getValueStrFromSections: createDateStrForInputFromSections,\n  getActiveDateManager: function getActiveDateManager(utils, state) {\n    return {\n      date: state.value,\n      referenceDate: state.referenceValue,\n      getSections: function getSections(sections) {\n        return sections;\n      },\n      getNewValuesFromNewActiveDate: function getNewValuesFromNewActiveDate(newActiveDate) {\n        return {\n          value: newActiveDate,\n          referenceValue: newActiveDate == null || !utils.isValid(newActiveDate) ? state.referenceValue : newActiveDate\n        };\n      }\n    };\n  },\n  parseValueStr: function parseValueStr(valueStr, referenceValue, parseDate) {\n    return parseDate(valueStr.trim(), referenceValue);\n  }\n};","map":{"version":3,"names":["areDatesEqual","replaceInvalidDateByNull","addPositionPropertiesToSections","createDateStrForInputFromSections","singleItemValueManager","emptyValue","getTodayValue","utils","valueType","startOfDay","date","cleanValue","areValuesEqual","isSameError","a","b","hasError","error","defaultErrorState","singleItemFieldValueManager","updateReferenceValue","value","prevReferenceValue","isValid","getSectionsFromValue","prevSections","isRTL","getSectionsFromDate","shouldReUsePrevDateSections","getValueStrFromSections","getActiveDateManager","state","referenceDate","referenceValue","getSections","sections","getNewValuesFromNewActiveDate","newActiveDate","parseValueStr","valueStr","parseDate","trim"],"sources":["/home/yasha/Desktop/Clarity_Plus_Package-Frontend-/node_modules/@mui/x-date-pickers/internals/utils/valueManagers.js"],"sourcesContent":["import { areDatesEqual, replaceInvalidDateByNull } from './date-utils';\nimport { addPositionPropertiesToSections, createDateStrForInputFromSections } from '../hooks/useField/useField.utils';\nexport const singleItemValueManager = {\n  emptyValue: null,\n  getTodayValue: (utils, valueType) => valueType === 'date' ? utils.startOfDay(utils.date()) : utils.date(),\n  cleanValue: replaceInvalidDateByNull,\n  areValuesEqual: areDatesEqual,\n  isSameError: (a, b) => a === b,\n  hasError: error => error != null,\n  defaultErrorState: null\n};\nexport const singleItemFieldValueManager = {\n  updateReferenceValue: (utils, value, prevReferenceValue) => value == null || !utils.isValid(value) ? prevReferenceValue : value,\n  getSectionsFromValue: (utils, date, prevSections, isRTL, getSectionsFromDate) => {\n    const shouldReUsePrevDateSections = !utils.isValid(date) && !!prevSections;\n    if (shouldReUsePrevDateSections) {\n      return prevSections;\n    }\n    return addPositionPropertiesToSections(getSectionsFromDate(date), isRTL);\n  },\n  getValueStrFromSections: createDateStrForInputFromSections,\n  getActiveDateManager: (utils, state) => ({\n    date: state.value,\n    referenceDate: state.referenceValue,\n    getSections: sections => sections,\n    getNewValuesFromNewActiveDate: newActiveDate => ({\n      value: newActiveDate,\n      referenceValue: newActiveDate == null || !utils.isValid(newActiveDate) ? state.referenceValue : newActiveDate\n    })\n  }),\n  parseValueStr: (valueStr, referenceValue, parseDate) => parseDate(valueStr.trim(), referenceValue)\n};"],"mappings":"AAAA,SAASA,aAAa,EAAEC,wBAAwB,QAAQ,cAAc;AACtE,SAASC,+BAA+B,EAAEC,iCAAiC,QAAQ,kCAAkC;AACrH,OAAO,IAAMC,sBAAsB,GAAG;EACpCC,UAAU,EAAE,IAAI;EAChBC,aAAa,EAAE,SAAAA,cAACC,KAAK,EAAEC,SAAS;IAAA,OAAKA,SAAS,KAAK,MAAM,GAAGD,KAAK,CAACE,UAAU,CAACF,KAAK,CAACG,IAAI,EAAE,CAAC,GAAGH,KAAK,CAACG,IAAI,EAAE;EAAA;EACzGC,UAAU,EAAEV,wBAAwB;EACpCW,cAAc,EAAEZ,aAAa;EAC7Ba,WAAW,EAAE,SAAAA,YAACC,CAAC,EAAEC,CAAC;IAAA,OAAKD,CAAC,KAAKC,CAAC;EAAA;EAC9BC,QAAQ,EAAE,SAAAA,SAAAC,KAAK;IAAA,OAAIA,KAAK,IAAI,IAAI;EAAA;EAChCC,iBAAiB,EAAE;AACrB,CAAC;AACD,OAAO,IAAMC,2BAA2B,GAAG;EACzCC,oBAAoB,EAAE,SAAAA,qBAACb,KAAK,EAAEc,KAAK,EAAEC,kBAAkB;IAAA,OAAKD,KAAK,IAAI,IAAI,IAAI,CAACd,KAAK,CAACgB,OAAO,CAACF,KAAK,CAAC,GAAGC,kBAAkB,GAAGD,KAAK;EAAA;EAC/HG,oBAAoB,EAAE,SAAAA,qBAACjB,KAAK,EAAEG,IAAI,EAAEe,YAAY,EAAEC,KAAK,EAAEC,mBAAmB,EAAK;IAC/E,IAAMC,2BAA2B,GAAG,CAACrB,KAAK,CAACgB,OAAO,CAACb,IAAI,CAAC,IAAI,CAAC,CAACe,YAAY;IAC1E,IAAIG,2BAA2B,EAAE;MAC/B,OAAOH,YAAY;IACrB;IACA,OAAOvB,+BAA+B,CAACyB,mBAAmB,CAACjB,IAAI,CAAC,EAAEgB,KAAK,CAAC;EAC1E,CAAC;EACDG,uBAAuB,EAAE1B,iCAAiC;EAC1D2B,oBAAoB,EAAE,SAAAA,qBAACvB,KAAK,EAAEwB,KAAK;IAAA,OAAM;MACvCrB,IAAI,EAAEqB,KAAK,CAACV,KAAK;MACjBW,aAAa,EAAED,KAAK,CAACE,cAAc;MACnCC,WAAW,EAAE,SAAAA,YAAAC,QAAQ;QAAA,OAAIA,QAAQ;MAAA;MACjCC,6BAA6B,EAAE,SAAAA,8BAAAC,aAAa;QAAA,OAAK;UAC/ChB,KAAK,EAAEgB,aAAa;UACpBJ,cAAc,EAAEI,aAAa,IAAI,IAAI,IAAI,CAAC9B,KAAK,CAACgB,OAAO,CAACc,aAAa,CAAC,GAAGN,KAAK,CAACE,cAAc,GAAGI;QAClG,CAAC;MAAA;IACH,CAAC;EAAA,CAAC;EACFC,aAAa,EAAE,SAAAA,cAACC,QAAQ,EAAEN,cAAc,EAAEO,SAAS;IAAA,OAAKA,SAAS,CAACD,QAAQ,CAACE,IAAI,EAAE,EAAER,cAAc,CAAC;EAAA;AACpG,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}